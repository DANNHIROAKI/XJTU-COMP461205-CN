[TOC]

# 第四章——网络层

网络层实现了**主机到主机的通信服务**，与传输层和应用层不同的是：在网络中的每一台主机和路由器都有一个网络层部分。网络层是协议栈中最复杂的层次。

## 4.1 网络层概述

### 4.1.1 网络互连

世界上有数以百万计的网络，要实现这些网络的互连是一件相当困难的事情，因为这些网络并没有统一的标准。而让大家都使用同一个网络也是不可能的，因为用户的需求是多种多样的，不可能有一种单一的网络能够适应所有用户。虽然网络不可能一样，但是可以想办法**使用一种协议让路由器连接的网络都遵守这种协议**，在这种情况下可以将互连起来的网络看成一个虚拟互联网络。

**虚拟互联网络也就是逻辑互联网络**，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是可以利用协议使这些性能各异的网络让用户看起来好像是一个统一的网络，。这种协议就是网络层重点讨论的IP。

将网络互连起来肯定需要一些中间设备(又称为中间系统或中继系统)，根据中继系统所在的层次，可以有以下4种不同的中继系统。

> 1)物理层的中继系统:中继器或集线器。
>
> 2)数据链路层的中继系统:网桥或交换机。
>
> 3)网络层的中继系统:路由器。
>
> 4)网络层以上的中继系统:网关。

当中继系统是中继器或网桥时，一般并不称之为网络互连，因为这仅仅是把一个网络扩大了，仍然是一个网络。<mark>互联网都是指用路由器进行互连的网络。</mark>

但是要注意，IP 数据报的首部中有一个“首部检验和”。当它检验出IP数据报的首部出见了差错时，就将该数据报丢弃。因此，凡交付给目的主机的IP数据报都是IP数据报的首
没有出现差错的，或没有检测出来有差错的。这就是说，传输过程中出现差错的IP数据报都被丢弃了。

### 4.1.2 网络层的两个核心功能
网络层的作用是将分组（包）从一台发送主机移动到一台接收主机，为此需要两种重要的网络层功能：**路由选择**(确定哪一条路径)与**分组转发**(当一个分组到达时所采用的动作)，这也是路由器的主要功能

根据所需性能要求，可以采用适当的路由算法来构造路由表进行路由选择。不仅如此，该路由表还会根据从各相邻路由器所得到的关于整个网络的拓扑变化情况，动态地改变所选择的路由，以便得到最佳路由。

> :one:**路由选择: 是指确定分组从源到目的地所采取的端到端路径的网络范围处理过程。路由选择发生的时间尺度长得多（通常为几秒），因此通常用软件来实现**。如果子网内部使用数据报，那么对每一个进来的分组都要重新选择路径。如果子网内部使用虚电路，那么只有当创建一个新的虚电路时，才需要确定路由路径。
>
> :two: **分组转发：是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。转发发生的时间尺度很短（通常为几纳秒），因此通常用硬件来实现。——路由器的核心功能**

:label: 用驾驶的例子进行类比，考虑旅行者所历经的从宾夕法尼亚州到佛罗里达州的行程。在这个行程中，那位驾驶员在到佛罗里达州的途中经过许多立交桥。我们能够认为**转发就像通过单个立交桥的过程**：一辆汽车从其道路上进入立交桥的个入口，并且决定应当走哪条路来离开该立交桥。我们可以把**路由选择看作是规划从宾夕法尼亚州到佛罗里达州行程的过程**：在着手行程之前，驾驶员已经查阅了地图并在许多可行的路径中选择一条，其中每条路径都由一系列经立交桥连接的路段组成。

:label: 路由表是**根据路由选择算法**得出的，而转发表是从路由表得出的。转发表的结构应当使查找过程最优化，路由表则需要对网络拓扑变化的计算最优化。在讨论路由选择的原理时，往往不去区分转发表和路由表，而是笼统地使用路由表这一名词。

### 4.1.3 连接建立

某些网络架构中（如ATM网络架构）的第三个重要功能——连接建立

在数据报流动之前，两端主机和中间路由器建立虚拟连接：路由器参与

> 通过拨号建立逻辑上的连接，中间的交换设备参与连接建立，维护一些中间信息：有多少连接，带宽资源是多少。当一些数据包到达交换设备时方便直接转发。排队时间短。
>
> 也不会出现乱序的问题：路径固定
>

网络与传输层连接服务:

> 网络:在两台主机之间(在VCs的情况下可能会涉及到中间路由器)
>
> 传输:两个进程之间，不涉及路由器

### 4.1.4 网络层服务模型

![image-20220413103043536](https://img-blog.csdnimg.cn/img_convert/879c0a643cdb46834a505c76fb9b0981.png)

### 4.1.5 虚电路vc网络

从源到目的t路径的行为很像电话线路。

> 在数据通信之前建立虚电路,通信结束后撤销(teardown)该虚电路; 
>
> 每个包包含一个虚电路ID (VC  identifier)
>
> 每个在源-目的之间的路由器维持连接状态; 需要预留资源.
>
> 通信之前就知道通信质量如何.

一个虚电路包括

> :one: 从发送端到接受端的路径;
>
> :two: 虚电路号，每条路径对应一个数字
>
> :three: 沿路路由的转发表项

**每经过一个交换机,虚电路号就会改变一次;**

每个交换设备都会维护一个交换表,该表是事先确定好的。该表存储如下一个虚电路号等数据.

![image-20220413104014145](https://img-blog.csdnimg.cn/img_convert/2a881548a2a800d032cfeeb5041fcaed.png)

上图的转发表如下

| Incoming interface | Incoming VC # | Outgoing interface | Outgoing VC # |
| ------------------ | ------------- | ------------------ | ------------- |
| 1                  | 12            | 3                  | 22            |
| 2                  | 63            | 1                  | 18            |
| 3                  | 7             | 2                  | 17            |
| 1                  | 97            | 3                  | 87            |
| ……                 | ……            | ……                 | ……            |

路由器维护连接状态信息

#### 信令协议

用于建立,维护,撤销(teardown)虚电路(VC); 

应用于:  ATM, frame-relay, X.25, IPv6 ; 

IPv4 中没有应用.

## 4.2 路由器结构

<img src="https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/qshell/image-20220331151429700.png" alt="image-20220331151429700" style="zoom:60%;"/>

路由器的结构分为两大类：路由选择部分和分组转发部分

分组转发部分由三部分组成：**一组输入端口、交换结构和一组输出端口**

交换结构从输入端口接收到分组后，根据转发表对分组进行处理，然后从一个合适的输出端口转发出去。

路由器的两个功能

> :one: 运行路由算法/协议：RIP、OSPF、BGP：只有边界网关路由器才会运行BGP
>
> :two: 将数据包从输入链路转发到输出链路

### 4.2.1 输入端口

![image-20220502141010437](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220502141010437.png)

最左边物理层、中间链路层、最右边网络层

### 4.2.2 三种交换方式

![image-20220413111007594](https://img-blog.csdnimg.cn/img_convert/0fd3403e578794262f2683d74fb6c65f.png)

:one: 通过存储器进行交换：输入端口将数据包放到内存里,输出端口将其从内存中读走;

> 早期路由器采用这种方式,在CPU 的直接控制之下进行交换;
>
> 两次访问内存,两次使用总线,效率低;
>
> 速度被内存带宽所限制(每个数据包需要经过2 个总线交叉口)\
>
> ![image-20220413111628025](https://img-blog.csdnimg.cn/img_convert/69e3043e0033e4f5f3966163aaa421c8.png)

:two: 通过总线进行交换：任意输入端口的数据放到总线上,输出端口从总线上读取数据;

> 不涉及访问内存,数据发送到总线后直接发送到输出端口;
>
> 路由器性能多快取决于总线的带宽
>
> 可达32Gps

:three: 通过交叉开关网络crossbar进行交换：交叉开关网络横线与竖线的交叉点是一个“bar ”,当需要进行通信时“bar ”才会导通,平时是断开的.

### 4.2.3 输出端口

![image-20220413111853360](https://img-blog.csdnimg.cn/img_convert/68093a65ba64b6e1d1fc4dfec47fe0f5.png)

当数据报从交换结构到达的速度快于传输速率时，需要缓冲

调度原则：选择在队列中的数据报进行传输

**行头阻塞Head-of-the-Line (HOL) blocking**：多个输入端口同时转发到同一个输出端口,不能同时发送,因此只能错开转发.因为只能有一个数据包发送,其他数据包需要在队列里等待,因此阻塞了队列,使队列变长.可能会导致队列满,从而导致丢包.

![image-20220413112438780](https://img-blog.csdnimg.cn/img_convert/693efd0adda8398f60e0ff4704dc15e3.png)

## 4.3 IPv4

### 4.3.1 概述

#### 因特网网络层

![image-20220413112736911](https://img-blog.csdnimg.cn/img_convert/5f258ec162d151165dfac11a14f85ff7.png)

ICMP : 控制报文协议.用于差错报告,连通性检查.

IP :  Internet  Protocol

网络层可以分为两个子层,其中路由协议与ICMP 协议位于上面的子层, IP 协议位于下面的子层。部分路由信息与ICMP 报文可以直接封装在IP 包中传输.

#### IPv4网络特征

:one: 有数据直接发送,不需要在网络层建立链接.

:two: 不需要路由器维护状态.

:three: 当路由器收到数据报时,会将其中的网络部分取出,查路由表,对应哪个出口就转到哪个出口.

:four: 可以走不同的路径,因此可能后发的数据包比先发的数据包更早到达,可能出现乱序.

#### 转发表

![image-20220413104951814](https://img-blog.csdnimg.cn/img_convert/6b1b9aa37adb83a4d21d1e1d48b836e3.png)

采用最长前缀匹配原则

![image-20220413105403155](https://img-blog.csdnimg.cn/img_convert/ac0f346cc90b481690e1eea0dce37900.png)

![image-20220413105246695](https://img-blog.csdnimg.cn/img_convert/6d3752112fcd5e888a779d84190e4024.png)

第二个目的地址(DA)可以匹配接口2 (0011)和接口1(0011000),根据最长前缀原则,选择接口1

### 4.3.2 数据包格式

![image-20220413112947228](https://img-blog.csdnimg.cn/img_convert/f234d95e06cc6899ff611641709fc2dd.png)

IP的首部也是20个字节（20B)，跟TCP段头一样

:one: version：区别是IPv4还是IPv6，通信双方的版本必须一致

:two: head len：首部长

:three: type of service：服务类型，IPv6才有区别，IPv4未启用

:four: flags : 切片包时用的

:five: fragmentation : 将包切片时用的.

> 切片: 将IP 包切分成若干个比较小的片,使之能够放到信元中.
>
> 网络链路层有MTU (最大传输单元),不同的链路有不同的MTU.
>
> 对于较大的数据包,如果MTU 装不下包,则会将其切分.
>
> 被切分的数据包,只有在接收端才会进行装配.

:six: checksum：没用，链路层已经检查过01跳变了

:seven: 源IP地址、目的IP地址

### 4.3.3 IPv4地址

IP地址跟网络接口对应，不跟主机对应，路由器有许多接口也就有许多IP地址

<mark>同一网段，网络部分相同；不同网段，网络部分不同</mark>

IP地址由主机部分和网络部分组成

**IP 地址具有以下一些重要特点。**

> :one: IP地址是一种分等级的地址结构。分等级的两个好处如下:
>
> > IP地址管理机构在分配IP地址时只分配网络号，而剩下的主机号则由得到该络号的单位自行分配。这样就方便了IP 地址的管理。
> >
> > 路由器仅根据目的主机所连接的网络号来转发分组(而不考虑目的主机号),就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。
>
> :two: 实际上**IP地址是标志一个主机(或路由器)和一条链路的接口**。当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的IP地址，其网络号必须是不同的。这种主机称为多接口主机，例如，路由器的每个接口都有一个不同网络号的IP地址。
>
> :three: 用中继器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有相同的网络号
>
> :four: 所有分配到网络号的网络，不管是局域网还是广域网，地位都是平等的。

#### 地址分类

把整个因特网看作一个单一的，抽象的网络，IP地址就是给每个连接在网络上的主机（或路由器）分配一个在全世界范围内是唯一的32位的标识符。一般将IP地址分为A,B,C,D,E类地址（E类地址不使用）。

![image-20220329102141882](https://img-blog.csdnimg.cn/img_convert/7f3a46dbc59e7433524ed23b8a52cbdd.png)

> :one: A类地址高一位字段是网络部分，低三位字段是主机部分，最高位固定为0
>
> > 可以指派的网络数为$2^7-1$：网络地址全0为保留地址，“本网络”，网络号为01111111保留为环回地址
> >
> > 主机数最多为$2^{24}-2$
>
> :two: B类地址高两位字段是网络部分，低两位字段是主机部分，最高位固定为10
>
> > 网路地址128.0.0.0实际上不指派，所以最少从128.1.0.0开始，可以指派的网络数为$2^{14}-1$
> >
> > 主机数最多为$2^{16}-2$
>
> :three: C类地址高三位字段是网络部分，低一位字段是主机部分，最高位固定为110
>
> > 网路地址192.0.0.0实际上不指派，所以最少从192.1.0.0开始，可以指派的网络数为$2^{21}-1$
> >
> > 主机数最多为$2^{8}-2$
>
> :four: D类地址高四位字段是网络部分最高位固定为1110
>
> > 多播通信时作为目的地址
> >
> > 多播：类似于微信的群聊

#### 特殊IP地址

| 特殊地址             | 网络号 | 主机号       | 源地址或目的地址     |
| -------------------- | ------ | ------------ | -------------------- |
| 网络地址             | 特定的 | 全0          | 都不是               |
| 直接广播地址         | 特定的 | 全1          | 目的地址             |
| 受限广播地址         | 全1    | 全1          | 目的地址             |
| 这个网络上的这个主机 | 全0    | 全0          | 源地址或默认目的地址 |
| 这个网络上的特定主机 | 全0    | 特定的       | 目的地址             |
| 环回地址             | 127    | 不是全1或全0 | 源地址或目的地址     |

> :one: 直接广播地址：主机号全1，路由器使用这个地址把一个分组发送到一个特定的网络上的所有主机，所有主机都会收到具有这种类型的**目的地址**的分组.
>
> :two: 受限广播地址：IP为255.255.255.255，<mark>用于定义在当前网络（不是整个互联网）</mark>。会向本地局域网中的其他主机发送分组，路由器会阻拦其传播到局域网外。
>
> :three: 这个网络上的这个主机：IP为0.0.0.0，不知道自己的IP地址时的主机发送一个报文给引导服务器，使用0.0.0.0作为源地址，使用255.255.255.255作为目的地址
>
> :four: 这个网络上的特定主机：属于A类地址，用于向同一网络上的某个主机发送报文。
>
> :five: 环回地址：用于自我测试，属于A类地址

### 4.3.4 NAT

#### 概述

**NAT：network address translation 网络地址变换**

其实某些机构并不需要连接到因特网，只需要与内部的主机通信，这样如果还是按照全球IP地址去分配，则会大大浪费IP地址。

例如，100个机构各有100台主机，假设现在100个机构都分配全球IP 地址，就需要1000个全球IP地址，但是现在从所有的全球IP地址里面划分出100 个IP地址专门用作一些只需内部通信的机构使用，即100个机构都使用这100个地址，只需要100个IP地址就解决问题了。这100个IP地址在计算机网络中被称为专用地址，且**路由器看到专用地址时不转发**，所以说专用地址作为目的地址是不可能在因特网上传送的。因特网已经规定了以下地址作为专用地址。

> 10.0.0.0~10.255.255.255 (相当于一个A类网络)。
>
> 172.16.0.0~172.31.255.255 (相当于16个连续的B类网络)。
>
> 192.168.0.0~192.168.255.255 (相当于256个连续的C类网络)。

这种采用专用IP地址的互联网络称为专用互联网或本地互联网,或直接称为专用网。专用IP地址也叫作可重用地址。问题出现了，如果专用网的主机想和因特网的主机通信，怎么办?这时NAT就诞生了。**NAT就是将专用网内部使用的本地IP地址转换成有效的外部全球IP地址，使得整个专用网只需要一个全球IP地址就可以与因特网连通。**

由于这些本地IP地址是可重用的，因此NAT技术可大大节省IP地址的消耗。使用NAT技术，需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫作NAT路由器，它至少有-一个有效的外部全球IP地址。但是NAT并不能从根本上解决IP地址的耗尽问题,因为NAT并没有增加IP地址的个数。而**真正解决IP地址耗尽问题的是IPv6**

NAT使能路由器对于外部世界来说甚至不像一台路由器。相反NAT路由器对外界的行为就如同一个具有单一P地址的单一设备。在图中，所有离开家庭路由器流向更大因特网的报文都拥有一个源P地址138.76.29.7，且所有进入家庭的报文都拥有同一个目的P地址138.76.29.7。从本质上讲，NAT使能路由器对外界隐藏了家庭网络的细节。

> 家庭网络计算机是从哪儿得到其地址，路由器又是从哪儿得到它的单一IP地址的。在通常的情况下，答案是相同的，即DHCP!路由器从ISP的DHCP服务器得到它的地址，并且路由器运行一个DHCP服务器，为位于NAT-DHCP路由器控制的家庭网络地址空间中的计算机提供地址。

#### NAT转换表与示例

![image-20220413160409813](https://img-blog.csdnimg.cn/img_convert/2c4247e69cda889db043668cd6ac4ae6.png)

如果从广域网到达NAT路由器的所有数据报都有相同的目的IP地址（特别是对NAT 路由器广域网一侧的接口)，那么该路由器怎样知道它应将某个分组转发给哪个内部主机呢？

使用NAT路由器上的一张**NAT转换表(NAT translation table)**,并且在表项中包含了**端口号及其IP地址**。

考虑上图中的例子。

> :one: 假设一个用户坐在家庭网络主机10.0.0.1后，请求P地址为128.119.40.186的某台Web服务器（端口80）上的一个Wb页面。主机10.0.0.1为其指派了（任意）源端口号3345并将该数据报发送到LAN中。
>
> :two: NAT路由器收到该数据报，为该数据报生成一个新的源端口号5001，将源P替代为其广域网一侧接口的P地址138.76.29.7,且将源端口3345更换为新端口5001。当生成一个新的源端口号时，NAT路由器可选择任意一个当前未在NAT转换表中的源端口号。（注意到因为端口号字段为16比特长，NAT协议可支持超过60000个并行使用路由器广域网一侧单个P地址的连接)
>
> :three: 路由器中的NAT也在它的NAT转换表中增加一表项。Wb服务器并不知道刚到达的包含HTTP请求的数据报已被NAT路由器进行了改装，它会发回一个响应报文，其目的地址是NAT路由器的P地址，其目的端口是5001。
>
> :four: 当该报文到达NAT路由器时，路由器使用目的IP地址与目的端口号从NAT转换表中检索出家庭网络浏览器使用的适当IP地址(10.0.0.1)和目的端口号(3345)。于是，路由器重写该数据报的目的P地址与目的端口号，并向家庭网络转发该数据报。

进出都要涉及变换,因此会使通信效率下降.

#### NAT网关穿越问题

:one: 静态配置NAT表(Statically  Configure  NAT)

> 每有一个新的应用，就需要往NAT表中加一条表项
>
> 由网络管理员配置.

:two: 动态配置Universal  Plug  and  Play (UPnP)

> 通过软件自动添加
>
> 这类软件核心协议是IGD 协议(Internet  Gateway  Device  Protocol)

### 4.3.5 子网掩码Subnet Mask

#### 子网划分

两级IP地址划分的不够合理

> IP地址利用率很低
>
> 给每个物理网络分配一个网络号会使路由表变得太大而使网络性能变坏
>
> 两级的IP地址不够灵活

于是有子网划分，使两级的IP地址变为三级的IP地址。划分子网是一个单位内部的事情，单位对外仍然表现为没有划分子网的网络。

**划分子网的思路**：从主机号借用若干比特作为子网号，而主机号也就相应减少了若干个比特，网络号不变，于是IP地址可记作
$$
\text{IP地址}::=\{\text{<网络号>，<子网号>，<主机号>}\}
$$
凡是从其他网络发送给本单位某个主机的IP数据报，仍然根据IP分组的目的网络号先找到连接在本单位网络上的路由器。然后此路由器在收到IP数据报后，再按照目的网络号和子网号找到目的子网，最后将IP数据报交给目的主机

#### 子网掩码

子网划分与否是看不出来的，如果要告诉主机或路由器是否对一个A类、B类、C类网络进行了子网划分，则需要子网掩码。

子网掩码是一个与IP地址相对应的32位的二进制串，它由一串1和0组成。其中，1对应于IP地址中的网络号和子网号，0对应于主机号。因为1对1进行与操作，结果为1；1对0进行与操作，结果为0。所以使用一串1对网络号和子网号进行与操作，就可以得到网络号。

:label: 不管网络有没有划分子网，只要将子网掩码和IP地址进行逐位的“与”运算，就一定能得到子网地址

如果没有给出子网掩码，则采用默认的：A：255.0.0.0、B：255.255.0.0、C：255.255.255.0

> IP地址：32位地址
>
> 网络地址：32位地址，网络部分不变，后面为0
>
> 子网地址：32位地址，子网以前不变，后面为0

### 4.3.6 CIDR无类别域间路由选择

classless interdomain routing无类别域间路由选择

a.b.c.d/x 代表高x 位是子网部分.

![image-20220413154037936](https://img-blog.csdnimg.cn/img_convert/f503c31fd61d2622ccac6fbb69086d12.png)

### 4.3.7 DHCP

Dynamic Host Configuration Protocol动态主机配置协议：给主机动态地分配IP地址

他是一个**应用层协议**，DHCP报文使用**UDP**传输

它提供了**即插即用连网的机制**，这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与。例如，现在有一台主机需要 IP地址。在该主机启动时就可以向DHCP服务器广播发送报文，将源地址设置为`0.0.0.0`,目的地址设置为`255.255.255.255`(特殊IP地址)。这时主机就成为DHICP 的客户，发送广播报文主要是因为现在该主机还不知道DHCP在哪，这样在本网络上的所有主机都能够收到该广播报文，但是只有DHCP服务器能够应答。DHCP服务器先在其数据库中查找该计算机的配置信息，若找到，则返回找到的信息，若找不到，则从服务器的IP地址池中取一个地址分配给该计算机。

DHCP服务器和DHCP客户端的交换过程如下（4路广播）

> :one: DHCP客户端广播<mark>"DHCP discover"</mark>报文，试图找到网络中的DHCP服务器，服务器获得一个IP地址
>
> :two: DHCP服务器收到报文后，就向网络中广播<mark>"DHCP offer"</mark>报文，其中包括提供DHCP客户端的IP地址和相关配置信息
>
> :three: DHCP客户机收到<mark>“DHCP offer”</mark>报文，如果接受DHCP服务器所提供的相关参数，则通过广播“DHCP request”报文向DHCP服务器请求提供IP地址。
>
> :four: DHCP服务器广播<mark>“DHCP ack”</mark>报文，将IP地址分配给DHCP客户机。同时其他DHCP 服务器将其IP 地址收回。
>
> DHCP允许网络上配置多台DHCP服务器，当DHCP客户发出DHCP请求时，就有可能收到多个应答报文。这时，DHCP客户只会挑选其中的一个，通常是挑选“最先到达的报文。
>
> ![image-20220413154204422](https://img-blog.csdnimg.cn/img_convert/1710c8f41070e5871f862f6b842fa6c6.png)

除了主机IP地址分配以外，DHCP还允许一台主机得到其他信息：

> 它的子网掩码
>
> 它的第一跳路由器地址（默认网关）
>
> 它的本地DNS服务器地址

### 4.3.8 ICMP

Internet Control Message Protocol 网络控制报文协议

主机在发送数据报时，经常会由于各种原因**发送错误**，如路由器拥塞丢弃了或者传输计程中出现错误丢弃了(注意:如果是首部出错，当然可以发，但是一般都不发，因为首部中错很有可能是源IP地址都错了，所以即使发了源主机也不一定收到)。如果检测出错误的路由器或主机都能把这些错误报告通过一些控制消息告诉发送数据的主机，那么发送数据的主机就可根据ICMP报文确定发生错误的类型，并确定如何才能更好地重发失败的数据报(比如ICMP报文发过来的是改变路由，那么主机就不能继续按照这个路由线路发送了，需要用另外一条路由线路发送数据)。尽管这些控制消息并不传输用户数据，但是对于用户数据的传递起着重要的作用。

ICMP报文分为两种，即ICMP差错报告报文和ICMP询问报文。

:one: **ICMP差错报告报文的分类**

> 1)终点不可达。当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。
>
> 2)源站抑制。当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。
>
> 3)时间超过。当IP分组的TTL值被减为0后，路由器除了要丢弃该分组外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。
>
> 4)参数问题。当路由器或目的主机收到的数据报的首部中有字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文(现在一般都不发)。
>
> 5)改变路由(重定向)。路由器把改变路由报文发送给主机，让主机知道下次应将数措报发送给其他的路由器(比当前更好的路由)。

:two: 询问报文的分类

> 1)有回送请求和回答报文。
>
> 2)时间戳请求和回答报文。
>
> 3)掩码地址请求和回答报文。
>
> 4)路由器询问和通告报文。

:three: 不应发送ICMP差错报告报文的几种情况

> 1)对ICMP差错报告报文不再发送ICMP差错报告报文。
>
> 2)对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文。
>
> 3)对具有组播地址的数据报都不发送ICMP差错报告报文。
>
> 4)对具有特殊地址(如127.0.0.0或0.0.0.0)的数据报不发送ICMP差错报告报文。

ICMP的两个典型应用，其实在日常生活中经常用，即**ping和tracert**.。

> ping 用来测试两个主机之间的连通性。ping 使用了ICMP**回送请求与回送回答**报文。ping 是**应用层**直接使用网络层ICMP的例子，它没有通过传输层的TCP或UDP。
>
> tracert（使用UDP）可以用来跟踪分组经过的路由，它工作在**网络层**。


## 4.4 IPv6

### 4.4.1 IPv6的特点

由于IPv4地址即将耗尽，因此必须采取相应的办法去解决。前面已经介绍过采用网址转换（NAT)方法以节省全球IP地址和采用无分类编址（CIDR)使IP地址的分配更加理。这两种方法仅是优化了IPV4地址的使用方法，并没有从根本上解决IP地址的耗尽向题而采用具有**更大地址空间的新版本的IPv6**才能在真正意义上解决IPv4即将耗尽的问题。

总结IPv6的主要特点。

> 1)更大的地址空间。IPv6将地址从IPv4的32位增大到了128位。
>
> 2)扩展的地址层次结构。因为地址多了，所以可以划分更多的层次。
>
> 3)灵活的首部格式。
>
> 4)改进的选项。
>
> 5)允许协议继续扩充。
>
> 6)支持即插即用（自动配置）。
>
> 7)支持资源的预分配。
>
> 8)IPv6首部长度必须是8B的整数倍，而IPv4首部是4B的整数倍

虽然IPv6与IPv4不兼容，但总的来说它跟所有其他的因特网协议兼容，包括TCP、UDP、ICMP、DNS等，只是在少数地方做了必要的修改（大部分是为了处理长的地址）。IPv6相当好地满足了预定的目标，主要体现在以下3个方面。

> 1)IPv6第一个主要改进也是最重要的，即IPv6有比IPv4长得多的地址。
>
> 2)IPv6第二个主要改进是简化了IP分组的基本首部，它包含8个段（IPv4是12个段）。这一改变使得路由器能够**更快地处理数据报**，从而可以改善吞吐率。
>
> 3)IPv6第三个主要改进是IPv6更好地支持选项。这一改变对新的分组首部很重要，因为一些从前是必要的段现在变成可选的了。此外，表示选项的方式也有所不同，使得路由器能够简单地跳过与它们无关的选项。这一特征加快了数据报处理速度。

### 4.4.2  IPv6格式

IPv6的首部格式如下（一共40B）：

![image-20220502133146399](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220502133146399.png)

优先级priority：确定流中数据报的优先级

流标号flow label：识别相同“流”的数据报。

下一个报头next header：识别数据的上层协议

### 4.4.2 从IPv4转变到IPv6

IPv4和IPv6混合的网络将如何运行?

> 隧道技术*Tunneling*
>
> 双栈技术*Dual-stack*

:one: **双栈技术*Dual-stack***

![image-20220502133215019](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220502133215019.png)

到达边缘路由器的时候将包进行转换（IPv4<->IPv6）

:two: **隧道技术*Tunneling***

![image-20220506210033288](https://note-image-1307786938.cos.ap-beijing.myqcloud.com/typora/image-20220506210033288.png)

将IPv6(IPv4)的包整个封装到IPv4(IPv6)的包中

隧道技术不止这一种

## 4.5 路由算法

### 4.5.1 路由算法的种类

路由器转发分组是通过路由表转发的，而路由表是通过各种算法得到的。如果从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，则只有两大类，即静态路由选择策略（又称为非自适应路由选择）与动态路由选择策略（又称为自适应路由选择）。静态路由选择的特点是简单和开销小，但不能及时适应网络状态的变化。对于很小的网络，完全可以采用静态路由选择，自己手动配置每一条路由。动态路由选择的特点是能较好地适应网络状态的变化，但实现起来比较复杂，开销也较大。因此，动态路由适用于较复杂的网络。

现代的计算机网络通常使用动态路由选择算法。动态路由算法又可分为两种基本类型：**距离－向量路由算法和链路状态路由算法**。

**全局性**的路由算法：链路状态路由算法，维护一个全局的拓扑图。

**分散性**的路由算法：距离－向量路由算法

### 4.5.2 距离－向量路由算法“distance vector” algorithms

#### 算法说明

不要求维护一个全局的拓扑图

**距离向量(Distance-Vector,DV)算法**是一种<mark>**迭代的、异步的和分布式**</mark>的算法，而LS算法是一种使用全局信息的算法。

> :one: **分布式的**：因为每个节点都要从一个或多个直接相连邻居接收某些信息，执行计算，然后将其计算结果分发给邻居。
>
> :two: **迭代的**：此过程一直要持续到邻居之间无更多信息要交换为止。此算法是自我终止的，即没有计算应该停止的信号，它就停止了。
>
> :three: **异步的**：是因为它不要求所有节点相互之间步伐一致地操作。
>
> :four: **自终止性**

令$d_x(\text{y})$是从**结点x到结点y的最低开销路径的开销**，则该路径开销与Bellman-Ford方程相关
$$
d_x(\text{y})=min_v\{c(x,v)+d_v(\text{y})\}
$$
方程中的$min_v$**是对于x的所有邻居的**。Bellman-Ford方程是相当直观的。实际上，从x到v遍历之后，如果我们接下来取从v到y的最低开销路径，则该路径开销将是$c(x,v)+d_v(y)$。因此我们必须通过遍历某些邻居v开始，**从x到y的最低开销是对所有邻居v的$c(x,v)+d_v(y)$的最小值**。

令$\pmb{D}_x=[\pmb{D}_x(y):y\in N]$是节点x的距离向量，该向量是**从x到在N中的所有其他节点y的开销估计向量**，使用DV算法，**每个结点x维护以下路由选择信息**

> :one: 对于每个邻居v，从x到直接邻居v的开销为c(x,v)
>
> :two: 结点x的距离向量，即$\pmb{D}_x=[\pmb{D}_x(y):y\in N]$，包含了从x到在N中的所有其他节点y的开销估计向量
>
> :three: 它的每个邻居的距离向量，对x的每个邻居v，有$\pmb{D}_v=[\pmb{D}_v(y):y\in N]$

在该算法中，每个节点周期性地向它的每个邻居发送它的距离向量副本，当当节点x从它的任何一个邻居v接收到一个**新距离向量**，它保存v的距离向量，然后使用Bellman-Ford方程更新它自己的距离向量如下：
$$
\pmb{D}_x(\text{y})=min_v\{c(x,v)+\pmb{D}_v(\text{y})\}\quad 对于N中的每个结点
$$
**如果节点x的距离向量因这个更新步骤而改变，节点x接下来将向它的每个邻居发送其更新后的距离向量，这继而让所有邻居更新它们自己的距离向量。**只要所有的节点继续以异步方式交换它们的距离向量，每个开销估计$\pmb D_v(y)$收敛到$d_v(y)$，$d_v(y)$为从节点x到节点y的实际最低开销路径的开销

<mark>算法伪代码如下(背下来)</mark>

```c
Initialization:
	for(all destination nodes y){
		if(y is a neighbor)
			Dx(y)=c(x,y)
		else{
			Dx(y)=infinity
		}
	}		
	for(each neighbor w){
		send distance vector Dx=[Dx(y):y in N] to w
	}
loop
	wait(until I see a link cost change to neighbor w or until I receive update from neighbor w)
	for(each destinations y){
		Dx(y)=min_v {c(x,v)+D_v(y)}
	}
	if(Dx(y) changed for any destination y){
 send new value of min Dx(y) to all neighbors 
}
forever
```

**举例说明**

![image-20220407144954467](https://img-blog.csdnimg.cn/img_convert/679e2314c38e6e6587d65a3d85b5e70e.png)

该图最左边一列显示了这3个节点各自的初始路由选择表(routing table)。例如，位于左上角的表是节点x的初始路由选择表。在一张特定的路由选择表中，每行是一个距离向量一特别是每个节点的路由选择表包括了它的距离向量和它的每个邻居的距离向量。因此，在节点x的初始路由选择表中的第一行是$\pmb D_x=[\pmb D_x(x),\pmb D_x(y),\pmb D_x(z)]=[0,2,7]$。在该表的第二和第三行是最近分别从节点y和z收到的距离向量。因为在初始化时节点x还没有从节点y和z收到任何东西，所以第二行和第三行表项中被初始化为无穷大。

初始化后，每个节点向它的两个邻居发送其距离向量。图5-6中用从表的第一列到表的第二列的箭头说明了这一情况。例如，节点x向两个节点y和z发送了它的距离向量,$\pmb D_x=[0,2,7]$。在接收到该更新后，每个节点重新计算它自己的距离向量。例如，节点x计算
$$
\begin{align}
&\pmb D_x(x)=0\\
&\pmb D_x(y)=\text{min}\{c(x,y)+\pmb D_y(y),c(x,z)+\pmb D_z(y)\}=\text{min}\{2+0,7+1\}=2\\
&\pmb D_x(z)=\text{min}\{c(x,y)+\pmb D_y(z),c(x,z)+\pmb D_z(z)\}=\text{min}\{2+1,7+0\}=3\\
\end{align}
$$
第二列因此为**每个节点显示了节点的新距离向量连同刚从它的邻居接收到的距离向量**。注意到，例如节点x到节点z的最低开销估计$D_x(z)$已经从7变成了3。

从邻居接收更新距离向量、重新计算路由选择表项和通知邻居到目的地的最低开销路径的开销已经变化的过程继续下去，直到无更新报文发送为止。在这个时候，因为无更新报文发送，将不会出现进一步的路由选择表计算，该算法将进入静止状态，即所有的节点将执行DV算法的中的**等待**。该算法停留在静止状态，<mark>**直到一条链路开销发生改变**</mark>，如下面所讨论的那样。

#### 链路开销改变与链路故障

当一个运行DV算法的节点检测到从它自己到邻居的链路开销发生变化时（I see a link cost change to neighbor w )，它就更新其距离向量并且如果最低开销路径的开销发生了变化，向邻居通知其新的距离向量。

##### 好消息传达速度快

下图示了从y到x的链路开销从4变为1的情况。我们在此**只关注y与z到目的地x的距离表中的有关表项。该DV算法导致下列事件序列的出现**

![image-20220407153504800](https://img-blog.csdnimg.cn/img_convert/fdddeaefcae60a4c581f29899c923444.png)

> :one: 在$t_0$时刻，y检测到链路开销变化（开销从4变为1），更新其距离向量，并通知其邻居这个变化，因为最低开销路径的开销已改变。
>
> :two: 在$t_1$时刻，z收到来自y的更新报文并更新了其距离表。它计算出到x的新最低开销（从开销5减为开销2），它向其邻居发送了它的新距离向量。
>
> :three: 在$t_2$时刻，y收到来自z的更新并更新其距离表。y的最低开销未变，因此y不发送任何报文给z。该算法进入静止状态。

![image-20220407154218015](https://img-blog.csdnimg.cn/img_convert/cc2e928f63674bea7e32ed644b9789ad.png)

因此，对于该DV算法只**需两次迭代就到达了静止状态**。在x与y之间开销减少的好消息通过网络得到了迅速传播。

##### 坏的消息传送速度慢

假设x与y之间的链路开销从4增加到60，此时整个链路图变化如下：

:one:在链路开销变化之前，D,(x)=4,D,(z)=1,D(y)=1和D,(x)=5。在t0时刻，y检测到链路开销变化（开销从4变为60）。y计算它到x的新的最低开销路径的开销，其值为
$$
D_y(x)=min\{c(y,x)+D_x(x),c(y,z)+D_z(x)\}=min\{60+0,1+5\}=6
$$
当然，从网络全局的视角来看，我们能够看出经过z的这个新开销是错误的。但节点y仅有的信息是：它到x的直接开销是60，且z上次已告诉y,z能以开销5到x。因此，为了到达x,y将通过z路由，完全期望z能以开销5到达x。到了t1时刻，我们遇到**路由选择环路(routing loop),即为到达x,y通过z路由，z又通过y路由**。路由选择环路就像一个黑洞，即目的地为x的分组在1时刻到达y或z后，将在这两个节点之间不停地（或直到转发表发生改变为止)来回反复。

:two: 因为节点y已算出到x的新的最低开销，它在t,时刻将该新距离向量通知z。

:three: 在t1后某个时间，z收到y的新距离向量，它指示了y到x的最低开销是6。z知道它能以开销1到达y,因此计算出到x的新最低开销$D_z(x)=min\{50+0,1+6\}=7$。因为z到x的最低开销已增加了，于是它便在2时刻通知y其新开销。

:four: 以类似方式，在收到z的新距离向量后，y决定D,(x)=8并向z发送其距离向量。接下来z确定D,(x)=9并向y发送其距离向量，等等

以上的过程要一直迭代44次，知道z最终算出它经由y的路径开销大于50为止。这种坏消息会造成**无穷计数问题**count to infinity

![image-20220407154848619](https://img-blog.csdnimg.cn/img_convert/39048b05e4dc7b5681fc7f7fc81aadbc.png)

#### 算法改进：增加毒性逆转poisoned reverse

如果z通过y路由选择到目的地x,则z将通告y,它(即z)到x的距离是无穷大，也就是z将向y通告$D_z(x)=∞$（即使z实际上知道$D_z(x)=
5$)。只要z经y路由选择到x,z就持续地向y讲述这个**善意的谎言**。因为y相信z没有到x的路径，故只要z继续经y路由选择到x(并这样去撒谎)，y将永远不会试图经由z路由选择到x。

但是3个或更多节点（而不只是两个直接相连的邻居节点）的环路将无法通过该技术检测到

![image-20220407155256448](https://img-blog.csdnimg.cn/img_convert/52c3fb16ab32adbf4ad4abb67066f951.png)



### 4.5.3 链路状态路由算法“link state” algorithms

链路状态路由算法要求每个参与该算法的节点都有完全的网络拓扑信息，它们执行下述两项任务。

:one: 主动测试所有邻接节点的状态。两个共享一条链接的节点是相邻节点，它们连接到同一条链路

:two:定期地将链路状态传播给其他所有节点

#### Dijkstra 算法（重要）

**概述**

> 网络拓扑结构，所有节点都知道链路开销
>
> 通过“link state broadcast”完成所有节点都有相同的信息
>
> 计算从一个节点(“源”)到所有其他节点的最小开销路径
>
> 迭代:经过k次迭代，知道到达k dest的最小代价路径

**符号**

> C (x,y):节点x到y的链路开销;如果不是直接邻居=∞
>
> D(v):从source到dest的路径开销的当前值
>
> P (v):从源到v路径上的<mark>**前继节点**</mark>
>
> N':已知最小代价路径的节点集合

**算法伪代码**

```c
Initialization: 
 N'= {u}
 for all nodes v 
 if v adjacent to u 
 then D(v)= c(u,v)
 else D(v)= ∞
 Loop 
 find w not in N' such that D(w) is a minimum 
/*在集合N'之外找离结点最近的结点w*/
 add w to N'
 update D(v) for all v adjacent to w and not in N': 
 D(v)= min( D(v), D(w)+ c(w,v))
 until all nodes in N'

```

![image-20220331173311285](https://img-blog.csdnimg.cn/img_convert/dc9d5bd5b088945c6e2f086eb4ae3529.png)

**时间代价**

> 算法复杂度:n个节点
>
> 每次迭代:需要检查所有节点w，而不是N
>
> n (n +1)/2的比较: $O (n^2)$
>
> 更有效的实现：$O(n\text{logn})$——优先队列
>
> 可能会产生振荡:
>
> 例如，链路成本=承载的流量

每个路由器在运行Dijkstra算法时会引入随机延迟

### 4.4.4 LS算法和DV算法的比较

DV和LS算法采用互补的方法来解决路由选择计算问题。在DV算法中，每个节点仅与它的直接相连的邻居交谈，但它为其邻居提供了从它自己到网络中（它所知道的）所有其他节点的最低开销估计。LS算法需要全局信息。因此，当在每台路由器中实现时，每个节点（经广播）与所有其他节点通信，但仅告诉它们与它直接相连链路的开销。我们通过快速比较它们各自的属性来总结所学的链路状态与距离向量算法。记住N是节点（路由器）的集合，而E是边（链路）的集合。

**报文复杂性**。我们已经看到**LS算法**要求每个节点都知道网络中每条链路的开销，这就要求要发送$O(|N||E|)$个报文。而且无论何时一条链路的开销改变时，必须向所有节点发送新的链路开销。DV算法要求在每次迭代时，**在两个直接相连邻居之间交换报文**。我们已经看到，算法收敛所需时间依赖于许多因素。当链路开销改变时，DV算法仅当在新的链路开销导致与该链路相连节点的最低开销路径发生改变时，才传播已改变的链路开销。

**收敛速度**。我们已经看到LS算法的实现是一个要求$O(|N||E|)$个报文的$O(|N|^2)$算法。**DV算法收敛较慢，且在收敛时会遇到路由选择环路。**DV算法还会遭遇无穷计数的问题。

**健壮性Robustness**。如果一台路由器发生故障、行为错乱或受到蓄意破坏时情况会怎样呢？

> LS算法：节点可以通告错误的**链路link开销**；每个节点只计算自己的转发表
>
> DV算法：节点可以通告不正确的**路径path开销**；每个节点的表被其他节点使用；错误通过网络传播

两个算法都有在使用。

## 4.6 路由选择

将路由器聚合成区域形成自治系统(AS：Autonomous System)

> 同一AS内的路由器运行相同的路由协议：**内部网关协议**（lInterior Gateway Protocols **(IGP)**）
>
> 不同AS中的路由器可以运行不同的AS内路由协议
>
> **边界网关协议BGP：broder gateway protocol**，所有的AS运行相同的AS间路由选择协议
>
> 一个自治系统由其全局唯一的AD号（ASN）所标识

网关路由器gateway router：直接连接到另一个AS中的路由器

### 4.6.1 路由选择

假设AS1中的路由器接收到发送到AS1以外的数据报：路由器应该将数据包转发到网关路由器，但是选择哪一个?

AS1所需要做:

> :one: 了解哪些路由可通过AS2访问，哪些路由可通过AS3访问
>
> :two: 将此可达性信息传播到AS1中的所有路由器

![image-20220413164511378](https://img-blog.csdnimg.cn/img_convert/b72d75e8f85b82068eb2229e4bb3fb3c.png)

#### 单个网关路由选择

![image-20220413164802258](https://img-blog.csdnimg.cn/img_convert/e21e00ac0e97f676c7804c5f9dd1efda.png)

假设AS1(通过跨AS协议)得知子网x可通过AS3(网关1c)到达，但不能通过AS2到达。跨网关协议将可达性信息传播到所有内部路由器。路由器1d根据内部AS的路由信息确定其接口$I$在通往1c的路径上的开销最小：于是添加转发表项(x,I)

#### 多个网关路由选择

![image-20220413165021877](https://img-blog.csdnimg.cn/img_convert/378961bd449000179c747e0597850c7e.png)

现在，假设AS1从内部AS协议中得知AS3和AS2的子网x是可达的。

要配置转发表，路由器1d必须确定将目的为x的数据包转发到哪个网关。

#### 确定最好的路由

##### 热土豆路由选择

热土豆路由选择依据的思想是：对于路由器1b,尽可能快地将分组送出其AS(更明确地说，用可能的最低开销)，而不担心其AS外部到目的地的余下部分的开销。

在路由转发表中增加AS外部目的地的步骤如下

> :one: 从AS间协议学到经多个网关可达子网x
>
> :two: 使用来自AS内部协议的路由选择信息，以决定到达每个网关的最低开销路径的开销
>
> :three: 热土豆路由选择：选择具有最小最低开销的网关
>
> :four: 从转发表确定通往最低开销网关的接口I，往转发表中添加表项转发表项(x,I)

> 如上图，1d离1b比较近就选择1b转发

### 4.6.2 IGP

常见的内部网关协议IGP如下

> **RIP:Routing Information Protocol路由信息协议**
>
> **OSPF:Open Shortest Path First开放最短路径优先**
>
> EIGRP：增强内部网关路由协议(Cisco专有)
>
> IS-IS:Intermediate System to Intermediate System,RFC 1122

#### RIP——路由信息协议

内部网关协议的一种

> :one: 使用距离矢量算法
>
> :two: AS内部最远的两点的距离不超过15跳，直径不超过15跳
>
> :three: 每30秒将距离矢量广播给邻居
>
> :four: AS周长不超过25跳
>
> :five: 每180秒没有收到来自邻居的信息，则认为跟邻居的链路断开了，BF方程重新进行计算
>
> > 链路故障的信息会很快传播给整个AS
>
> :six: 如果有多条最优路径，选择其中的一条走

![image-20220413195015871](https://img-blog.csdnimg.cn/img_convert/0ac1dd4642daefdb28163d2e1e33f4e7.png)

RIP路由表由应用程序级进程route-d (daemon)管理

> route-d工作在应用层
>
> 路由表在网络层

报文类型为UDP，周期性重复，端口为520

![image-20220413200017142](https://img-blog.csdnimg.cn/img_convert/274dea832d9e7d0d37582d612aa93755.png)

#### OSPF——开放最短路径优先

内部网关协议的一种

> :one: 使用链路状态算法
>
> > 使用链路状态数据包传播
> >
> > 需要维护每个节点的拓扑图
> >
> > 使用Dijkstra算法进行路由计算
>
> :two: 周期性地广播自己跟谁连，代价是多少，广播给整个AS，周期通常是30分钟
>
> :three: 报文直接封装在IP的报文中，**OSPF协议直接运行在网络层上部**，也是不可靠的协议

**OSPF的优势（相较于RIP)**

> :one: 安全性：两个路由器通信之前先对路由器进行认证authenticated，避免恶意入侵
>
> :two: 两点之间允许多条等价的最优路径，都可以走(RIP中只有一条路径)
>
> :three: 对同一条链路，传送不同业务时配置的代价可以不一样
>
> :four: 集成单播和多播支持
>
> :five: AS比较大时可以使用分层OSPF：各自在各自的domain中运行OSPF协议

### 4.6.3 BGP

AS之间的路由协议只有一个:BGP边界网关协议

采用路径-矢量协议

> 边界网关维护的一般不是路由表而是路径表

BGP为每个AS提供了一种方法:

> :one: 向邻居应用服务器获取子网可达性信息。
>
> :two: 将可达性信息传播到所有AS内部路由器。
>
> :three: 根据可达性信息和策略确定到AS的“好”路由。

允许**AS**向他的上一跳广播：我在这

**使用半永久的TCP连接**，可以通过会话（应用层）报文关闭

**路由选择**

> 根据本地的喜好制定策略，策略的优先级高于路径矢量算法
>
> 缺省时使用最短的路径
>
> 热土豆准则

**BGP的四种报文**

> OPEN报文：与相邻的另一个BGP发言人建立关系
>
> UPDATE报文：用于发送某一路由的信息以及列出要撤销的多条路由
>
> KEEPALIVE报文：用于确认打开报文和周期性地证实邻居关系
>
> NOTIFICATION报文：报告报文错误以及用来关闭TCP连接

### 4.6.4 RIP、OSPF、BGP比较

| 主要特点     | RIP                                                      | OSPF                                               | BGP                |
| ------------ | -------------------------------------------------------- | -------------------------------------------------- | ------------------ |
| 网关协议     | 内部                                                     | 内部                                               | 外部               |
| 路由表内容   | 目的网络，下一跳，距离                                   | 目的网络，下一跳，距离                             | 目的网络，完整路径 |
| 最优通路依据 | 跳数                                                     | 费用                                               | 多种有关策略       |
| 算法         | 距离-矢量算法                                            | 链路状态算法                                       | 路径-矢量算法      |
| 传送方式     | UDP                                                      | IP数据报                                           | TCP连接            |
| 其他         | 简单，效率低，跳数为16不可达，好消息传得快，坏消息传得慢 | 效率高、路由器频繁交换信息，难以维持一致性；规模大 |                    |



## 练习题

1、Which of the following are features of the Internet Protocol (IP)? (Choose two.)

> It is the most widely implemented global addressing scheme.:+1:
>
> It allows two hosts to share a single address on a local area network.
>
> It is a hierarchical addressing scheme allowing addresses to be grouped.:+1:
>
> It is only locally significant, used primarily on local area networks.

2、Which OSI layer defines the functions of a router?

>  physical 
>
>  data link 
>
>  network :+1:
>
>  transport 
>
>  session 

3、Which part of an IP address identifies a specific device on a network?

> first two octets 
>
> third and fourth octets 
>
> network portion 
>
> host portion :+1:
>
> only the fourth octet 

4、Which of the following will test the internal loopback of a node?

> ping 10.10.10.1 
>
> ping 192.168.1.1 
>
> ping 127.0.0.1 :+1: 
>
> ping 223.223.223.223 
>
> ping 255.255.255.255

5、Which protocol functions at the internet layer of the TCP/IP protocol suite?

> File Transfer Protocol (FTP)
>
> Trivial File Transfer Protocol (TFTP)
>
> Transmission Control Protocol (TCP)
>
> Internet Protocol (IP):+1:
>
> User Datagram Protocol (UDP)
>
> Simple Mail Transport Protocol (SMTP)

6、Using the IP address 38.159.163.37 with a subnet mask 255.255.255.240, determine the subnetwork address.

> 38.159.0.0 
>
> 38.159.163.0 
>
> 38.159.163.0 
>
> 38.159.163.16 
>
> 38.159.163.32 :+1:
>
> 38.159.163.36 

7、A company with a Class B license needs to have a minimum of 1,000 subnets with each subnet capable of accommodating 50 hosts. Which mask below is the appropriate one?

> 255.255.0.0 
>
> 255.255.240.0 
>
> 255.255.255.0 
>
> 255.255.255.192 :+1:
>
> 255.255.255.224 

8、Which of the following are Cisco proprietary routing protocols? (Choose two.)

> RIPv2 
>
> IGRP :+1:
>
> OSPF 
>
> BGP 
>
> RIPv1 
>
> EIGRP :+1:

9、When a network administrator applies the subnet mask 255.255.255.248 to a Class A address, for any given subnet, how many IP addresses are available to be assigned to devices?

> 1022 
>
> 510 
>
> 254 
>
> 126 
>
> 30 
>
> 6 :+1: 

10、Which OSI layer encapsulates data into packets?

> session 
>
> transport 
>
> network :+1: 
>
> data link 

## 参考资料

[1] James F.Kurose，Keith W.Ross.Computer Networking—A Top-Down Approach（第6版）.北京：高等教育出版社出版者，2013年。

[2] 西安交通大学Computer Networking2022年春 课程PPT 朱利

[3] 天勤第11版 2023版计算机网络高分笔记